# -*- coding:utf-8 -*-
"""
474. 一和零
给你一个二进制字符串数组 strs 和两个整数 m 和 n 。
请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。
如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。

示例 1：
输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。

示例 2：
输入：strs = ["10", "0", "1"], m = 1, n = 1
输出：2
解释：最大的子集是 {"0", "1"} ，所以答案是 2 。

提示：
1 <= strs.length <= 600
1 <= strs[i].length <= 100
strs[i] 仅由 '0' 和 '1' 组成
1 <= m, n <= 100

"""
from typing import List


class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        """
        背包问题
        eg: Array = {"10", "0001", "111001", "1", "0"}, m = 5, n = 3
        初始化背包，
        dp   0列    1列     2列     3列  （列表示背包1的可容纳大小）
        0行   0      0       0      0
        1行   0      0       0      0
        2行   0      0       0      0
        3行   0      0       0      0
        4行   0      0       0      0
        5行   0      0       0      0
        （行表示背包0的可容纳大小）        d[i][j]值表示 已经装了多少个元素了(同时存在"10", "0001", 就是2)
        --
        对于第一个01串 ‘10’
        可容纳的背包 （√表示可容纳 x表示不可容纳）
        dp   0列    1列       2列     3列
        0行   ×      ×       ×      ×
        1行   ×      √       √      √
        2行   ×      √       √      √
        3行   ×      √       √      √
        4行   ×      √       √      √
        5行   ×      √       √      √

        对于可容纳的背包要依次遍历，元素>容量, 跳过. 元素<=容量, 则　1（当前元素）+ 变小的 旧背包容量 　-> 取最大值
        dp   0列    1列     2列     3列
        0行   0      0       0      0
        1行   0      1       1      1
        2行   0      1       1      1
        3行   0      1       1      1
        4行   0      1       1      1
        5行   0      1       1      1
        --
        对于 第二个01串‘0001’
        可容纳的背包 （√表示可容纳 x表示不可容纳）
        dp   0列    1列       2列     3列
        0行   ×      ×       ×      ×
        1行   ×      ×       ×      ×
        2行   ×      ×       ×      ×
        3行   ×      √       √      √
        4行   ×      √       √      √
        5行   ×      √       √      √

        对于可容纳的背包要依次遍历，元素>容量, 跳过. 放，则 1（当前元素）+ 变小的 旧背包容量 -> 取最大值
        dp   0列    1列     2列     3列
        0行   0      0       0      0
        1行   0      1       1      1
        2行   0      1       1      1
        3行   0      1       1      1
        4行   0      1       2      2
        5行   0      1       2      2  <-- max（原本背包价值1【不放】， 1+旧背包dp[5-3][3-1]【放】）
        --


        :param strs:
        :param m:
        :param n:
        :return:
        """
        dp = [[0] * (n + 1) for _ in range(m + 1)]  # 建表

        for str_ in strs:
            str_0 = str_.count('0')
            str_1 = str_.count('1')

            for i in range(m, str_0 - 1, -1):  # 划定正常情况下可以存放的范围(列)
                for j in range(n, str_1 - 1, -1):  # 划定正常情况下可以存放的范围(行)
                    dp[i][j] = max(dp[i][j], dp[i - str_0][j - str_1] + 1)
                    # 最大-当前=剩下的空间有没有可能超标(遇到dp[i - str_0][j - str_1]=0的情况)

        return dp[m][n]


if __name__ == '__main__':
    input = ["10", "0001", "111001", "1", "0"]
    m = 5
    n = 3
    s = Solution()
    out = s.findMaxForm(input, m, n)
    print(out)
